---
title: 2 - C++/OpenGL
title_full: Langage C++ et OpenGL
---

<style>
    .cpp, .technique
    {
        border: 1px solid gray;
        padding: 5px;
        border-radius: 5px;
        font-size: 85%;
        color: rgb(80,80,80);
        line-height: 1.3em;
    }
    .cpp:before {
        content:"Aparté C++";
        font-style: italic;
    }

    .technique:before {
        content:"Aparté technique";
        font-style: italic;
    }
</style>

::[font-style:italic]
Dans cette partie, nous allons voir plus en détail les éléments de langage C++ et les bases d'OpenGL. Cette partie a pour objectif de vous aider à comprendre le fonctionnement de l'affichage graphique a bas-niveau (= proche du matériel), et ce qui se déroule plus précisément lors de l'initialisation des données et de l'affichage. <br>
Contrairement à la 1ère partie, les codes (et résultats graphiques) seront plus simples et n'utiliserons pas la bibliothèque CGP. Cela vous permettra de comprendre la logique et les fonctions sur laquelle se base la bibliothèque (ou tout autre moteur de rendu utilisant la carte graphique).

<br><br>

Notez que le contenu de cette partie est long et dense. Il intéressera principalement ceux souhaitant comprendre plus en détail le fonctionnement précis de l'affichage. Les apartés techniques sont à destination des étudiants aillant déjà des connaissances préalables en C++/OpenGL. <br>
Si vous débutez, n'hésitez pas à passer rapidement sur les points informatifs et visez la réalisation des exercices qui sont assez simples. Il sera toujours possible de revenir sur les notions détaillées plus tard lorsque vous y serez confrontés. Le plus important est que vous compreniez la logique générale.
::





== Tour d'horizon du langage C++

::[height:1em;]::

link::../cpp_technical_generality/index.html[**\(\Rightarrow\) Lien annexe de généralités sur le langage C++**]

=== Principes fondamentaux

==== Programme minimaliste

L'un des codes les plus simples en C++ est le suivant

code::[c++]
#include <iostream>
int main()
{
    std::cout << "Hello world" << std::endl;
    return 0;
}
code::[-]

Ce programme affiche sur la ligne de commande "Hello world" puis termine.
* - Vous pouvez trouver ce code et les scripts de compilations dans le répertoire 
** **scenes/inf443/02_opengl_cpp/01_basic_cpp/**
* - Le fichier source du code C++ est __src/main.cpp__

::[height:2em;]::

Voici l'explication de chaque ligne de ce code: 

::[height:2em;]::

* **#include &lt;iostream&gt;**
** - **#include** permet d'inclure le code d'un autre fichier. Il permet le mécanisme d'inclusion de bibliothèque externe en C++.
** - **#include &lt;FileName&gt;** permet l'inclusion du fichier nommé `FileName`. Les chevrons indiquent que ce fichier doit être préférentiellement cherché dans les fichiers système (ce qui est le cas pour iostream). Le mécanisme d'inclusion est très minimaliste car le contenu du fichier est littéralement copié/collé lors de la compilation.
** - **iostream** correspond à la bibliothèque standard C++ d'entrée sortie  (iostream = **I**nput **O**utput **S**tream). Elle permet en particulier l'affichage sur la ligne de commande. 

<br>

* **int main()**
** Correspond au point d'entrée, ou "de départ", de l'exécutable, c'est-à-dire la fonction qui va être appelée automatiquement lorsque vous lancez l'exécutable.
** Tout programme C++ doit nécessairement contenir une (et une seule) fonction appelée __main__.

<br>


* **std::cout &lt;&lt; "Hello World" &lt;&lt; std::endl;**
** **std &colon;&colon; cout &lt;&lt;** syntaxe standard pour afficher du texte sur la ligne de commande (ici "Hello World")
*** - **cout** signifie **C**ommon **Out**put. (réfère par défaut à la ligne de commande sauf si l'on a redirigé la sortie standard)
*** - **std::cout** est le nom complet de l'objet `cout` qui est présent dans l'espace de nommage (namespace) std (standard library).
*** - **&colon;&colon;** est appelé l'opérateur de résolution de portée (scope resolution operator). Ici il permet de trouver l'objet __cout__ dans l'espace de nom __std__
*** - **&lt;&lt;** est un opérateur C++ (c-a-d un symbole utilisé en tant que fonction). Ici l'opérateur __&lt;&lt;__ est utilisé pour envoyer la chaine de caractère (string) à l'objet __std::cout__ afin de l'afficher en ligne de commande.
** **&lt;&lt;std::endl** Ajout un saut de ligne à la fin de l'affichage. __endl__ réfère à **end** of **l**ine.

<br>

* **return 0;** Valeur de retour de l'exécutable (renvoi au processus appelant - par exemple la ligne de commande). Par convention une valeur de retour de 0 indique que le programme s'est terminé sans erreurs.

<br>


__Remarques générales__: 
* - Chaque instruction de code C++ doit nécessairement **terminer par un point virgule __;__**
* - Contrairement à Python, mais similairement à Java, l'idendation et les sauts de lignes n'ont pas d'importance sur l'exécution du code.

=== Outils de compilation


La compilation du code C++ nécessite d'appeler un compilateur (qui dépend de votre système d'exploitation) sur chaque fichier source de votre programme C++ (les fichiers d'extensions __.cpp__). Pour éviter d'avoir à lister manuellement l'ensemble des fichiers, nous utilisons la chaine de compilation suivante:

* - **CMake** est utilisé (avec le fichier CMakelists.txt) pour générer un projet listant l'ensemble des fichiers sources et de leur dépendance.
** - **Makefile** sous Linux/MacOS
** - **Projet Visual Studio** (.sln) sous Windows
* - La compilation est ensuite réalisé de manière transparente par votre IDE (Visual Studio/QtCreator), ou en appelant make en ligne de commande.

::[height:1em;]::

link::../cpp_compilation/index.html[**\(\Rightarrow\) Détails sur le processus de compilation**]




=== Types fondamentaux C++

Vous utiliserez principalement deux types fondamentaux dans vos codes:

* **int**: qui correspond à un nombre entier (integer). Sur nos machines, un int est encodé sur 4 octets.
** __ex. int = 325;__
* **float**: qui correspond à un nombre à virgule flottante dit à "simple précision". Sur nos machines, un float est encodé également sur 4 octets.
** __ex. float = 3.2f;__

::[height:1em;]::

Vous rencontrerez également les types suivants:

* **bool**: Valeur booléenne qui peut prendre la valeur true/false. 
** __Ce type est introduit en C++ (n'existe pas en C), et permet un code plus expressif que l'utilisation d'un entier.__
* **double**: Un nombre à virgule flottante dit à "double précision". Sur nos machines, un double est encodé sur 8 octets.
** __ex. double = 3.2;__
** __Ce type est celui utilisé par défaut (nombre à virgule sans extension), mais nous utiliserons dans notre cas davantage les "float" qui sont compatible avec la carte graphique__.
* **char**: Un caractère dont la correspondance entre valeur/caractère est donnée par la table ASCII.

::[height:1em;]::

::(.technique)
Le type __char__ possède la garantie d'être encodé sur 1 octet. Il peut être utilisé également à ce titre pour définir finement des valeurs en mémoires à l'octet prêt.
::

::[height:1em;]::

__Remarque__: En C++, les types fondamentaux ne sont pas initialisés à de valeurs spécifiques par défaut. 
* ex. "int a;" ne vaudra donc pas nécessairement 0 si on ne le définit pas explicitement avec "int a=0;". 
* \(\Rightarrow\) Pour éviter les "comportements indéterminés", il est donc préférable d'initialiser ces valeurs au moment de leur déclaration.


=== Notions basiques du langage

==== Déclaration de variables

Les variables doivent se déclarer avec leur type

code::[c++]
type nomVariable;
// ex. 
// int maVariable;
// float y;
code::[-]

Il est possible d'affecter une valeur directement lors de la déclaration

code::[c++]
type nomVariable = valeur;
// ou similairement:
//  type nomVariable(valeur);
//  type nomVariable = type(valeur);
code::[-]

::[height:2em;]::

Lorsqu'il n'y a pas d'ambiguité, le type peut être désigné par le mot clé "auto". Dans ce cas, le type est alors automatiquement déterminé par le compilateur.

code::[c++]
auto a = 5; // a est un int
code::[-]

__Pour des questions de lisibilité de code, on réservera cependant l'utilisation de auto à des types longs et complexes à écrire, et on explicitera par contre les types classiques.__

::[height:2em;]::

Il est possible de spécifier qu'une variable va être constante par le mot clé "const"

code::[c++]
type const nomVariable = valeur;
// ou similairement
const type nomVariable = valeur;
code::[-]

Une variable qualifiée de "const" ne peut plus voir sa valeur modifiée.

code::[c++]
int const a = 5;
a = 6; // erreur de compilation
code::[-]


__Remarque__: L'utilisation de "const" permet d'aider le programmeur à éviter de modifier la valeur d'une variable qui ne le devrait pas par inadvertance. Il s'agit principalement d'un mot clé permettant de préserver une bonne qualité de code et d'éviter des bugs.

==== Fonctions

Les fonctions suivent la syntaxe suivante

code::[c++]
typeRetour nomFonction(type nomArgument1, type nomArgument2, etc.)
{
    ... code de la fonction
    return value;
}
code::[-]

Exemple:
code::[c++]
int addition(int a, int b)
{
    return a+b;
}
code::[-]

* - Une fonction qui ne renvoie pas de valeur aura pour typeRetour **void**.
* - Une fonction qui ne prend pas d'argument aura simplement des parenthèses vides.
* - La première ligne décrivant le nom et les types de la fonction est appelée la **signature** ou l'**en-tête** de la fonction.
* - Le reste est appelé le **corps** ou **l'implémentation** de la fonction.


::[height:2em;]::

Il faut nécessairement que la signature d'une fonction soit **déclarée avant** son utilisation. Sinon il y aura une erreur de compilation. 

::[height:1em;]::

Exemples:

::[display:flex; font-size:85%;]
div::[]
code::[c++]
int addition(int a, int b)
{
    return a+b;
}

int main()
{
    // OK 
    // La signature (et le corps) 
    //  est déclarée avant.
    int c = addition(5,3);
}
code::[-]
::
div::[]
code::[c++]
int addition(int a, int b);

int main()
{
    // OK 
    // La signature et déclarée avant.
    int c = addition(5,3);
}

int addition(int a, int b)
{
    return a+b;
}
code::[-]
::
div::[]
code::[c++]
int main()
{
    // KO - ne compile pas, 
    //  la fonction "addition" 
    //  n'est pas déclarée.
    int c = addition(5,3);
}

int addition(int a, int b)
{
    return a+b;
}
code::[-]
::
::


==== Instructions conditionnelles

code::[c++]
if(condition) {
    ...
}
else if(autreCondition) {
    ...
}
else { // si aucune condition précédente n'est vérifiée
    ...
}
code::[-]

==== Boucles

code::[c++]
for(initialisation; conditionArret; increment){
    ...
}

// Exemple:
for(int k=0; k<5; k++) {
    std::cout<< k << std::endl;
}
code::[-]

__Remarque__: k++ (ou ++k) est identique à écrire k=k+1



==== Accolades

Les accolades sont nécessaires (à la suite d'un if, for, etc) dès lors qu'il y a plus d'une instruction. 

::[height:1em;]::

Exemple:

code::[c++]
for(int k=0; k<5; k++){
    std::cout<< k << std::endl;
}

// est identique à 
for(int k=0; k<5; k++)
    std::cout<< k << std::endl;
code::[-]

Par contre:

code::[c++]
for(int k=0; k<5; k++){
    std::cout<< k << std::endl;
    std::cout<<"Je suis également dans la boucle"<<std::endl;
}

// n'est pas identique à 
for(int k=0; k<5; k++)
    std::cout<< k << std::endl;
    std::cout<<"Attention, je suis hors de la boucle même si on m'indente"<<std::endl;
code::[-]


=== Struct et class

Les objets peuvent se déclarer avec les mots clés **struct** ou **class**.


code::[c++]
struct/class nomObject {
    public:
    // parametres et méthodes accessible publiquement
    private:
    // parametres et méthodes privées de l'objet.
};
code::[-]

::[height:1em;]::

Exemple de déclaration:

::[display:flex; font-size:95%;]
div::[]
code::[c++]
struct vec3 {
    float x, y, z;
    float norm() {
        return sqrt(x*x+y*y+z*z);
    }
};
code::[-]
::
div::[]
code::[c++]
class vec3 {
    public:
    float x, y, z;
    float norm() {
        return sqrt(x*x+y*y+z*z);
    }
};
code::[-]
::
::

Utilisation:
code::[c++]
int main()  {
    // Creation d'une instance de l'objet
    vec3 p = {5.3f, 1.1f, 3.2f};

    // Accès à un membre public
    p.y = -4.5f;

    // Appel à une méthode publique
    float n = p.norm();
}
code::[-]

::[height:2em;]::

__Remarques__: 
* - Les paramètres et méthodes d'une struct sont publics par défaut. Alors qu'ils sont privés pour une class. Il faut donc explicitement indiquer "public" pour une class, et pas nécessairement pour une struct. En dehors de cette différence, struct et class sont similaires.
* - Contrairement à Java(/Python), il n'est pas obligatoire de précéder le nom des paramètres par this(/self). pour y accéder dans les méthodes. 


=== Variables

En C++ le contenu des variables est placé par défaut sur la pile (heap memory). Cette mémoire est gérée automatiquement par le système d'exploitation, et est très rapide d'utilisation (les variables sont placées de manière contigues et la mémoire est pré-allouée par le système au lancement du programme). <br> Contrairement à Java, il n'y a donc pas besoin du mot clé "new" lors de la création d'une instance d'une classe. 

::(.technique)
* Le mot clé "new" existe également en C++ pour allouer manuellement de la mémoire dans une autre zone appelée le tas (stack memory), mais que nous n'utiliserons pas explicitement dans nos programmes
::

::[height:2em;]::

En C++, une **variable** désigne directement une **zone en mémoire**. 
* - Modifier une variable, revient à modifier le contenu d'une zone mémoire (la taille de la zone mémoire est fixe et dépend du type de la variable). 
* - Copier une variable avec l'opérateur "=" consiste à copier l'ensemble de la zone mémoire associée à cette variable.

code::[c++]
int main()
{
    vec3 a = {1,2,3};
    vec3 b = a; 
    // b est une nouvelle variable et donc une nouvelle zone en mémoire
    // le contenu de b est une copie du contenu de a
    b.x = 5; // modifier b.x ne modifie pas les valeurs de a
}
code::[-]


Ce comportement par défaut est différent des langages tels que Python ou Java, qui lors de l'utilisation de classes, vont appliquer une indirection: La variable ne désignant pas une zone mémoire, mais l'adresse de cette zone (en Python ou Java cette gestion est implicite, et on parle de "référence"). <br>
\(\Rightarrow\) En C++, la copie ou l'affectation (avec l'utilisation de l'opérateur "=", ou lors d'un passage de paramètre) réalise par défaut un "clone" du contenu des objets qui est dans la mémoire de la pile.  <br>
\(\Rightarrow\) Toute variable C++ est par défaut "mutable": on peut modifier le contenu de la mémoire.


::[height:2em;]::

La **durée de vie** des variables standard ("scope") est celle du bloc d'instruction dans laquelle elle est créée ("bloc scope") - c-a-d depuis sa déclaration jusqu'à l'accolade fermante "}" du bloc où elle a été créée. <br>

::[display:flex; font-size:85%;]
div::[]
code::[c++]
int main()
{
    if(someCondition) {
        int x = 5; // x est défini dans le bloc "if"
        ...
        // x existe jusqu'à la fin du bloc
    }
    // x n'existe plus ici 
}
code::[-]
::
div::[]
code::[c++]
int main()
{
    int x = 5; // x est défini dans le bloc
               //  de la fonction main()
    if(someCondition) {
        ...
        // x peut être utilisé ici (sous-bloc)
    }
    // x existe toujours jusqu'à la fin de main()
}
code::[-]
::
::

::[height:1em;]::

__Remarque__: 
* - Ce comportement est différent de celui de Python qui définit la durée de vie jusqu'à la fin de la fonction.
* - On ne peut pas définir plusieurs variables ayant le même nom dans un même bloc (il est possible de le faire dans des sous-blocs, mais c'est à éviter).
* - Bonne pratique: dans le cas général, préférez déclarer vos variables dans le bloc de plus courte durée de vie - cela améliore la lisibilité de votre code.

=== Adresses et pointeurs

Comme expliqué précédemment, une variable en C++ définie un emplacement en mémoire, et le type indique la taille en octets réservé à la suite de cet emplacement (ainsi que la manière de traiter les opérations qui s'y appliquent).
<br>

Cet "emplacement" est désigné par le terme "d'adresse" mémoire. Chaque variable possède donc une adresse qu'il est possible d'obtenir à l'aide de la syntaxe "&variable". 

::[height:1em;]::

Il est possible d'utiliser cette adresse comme un moyen indirect de désigner et de modifier une valeur en mémoire à l'aide de ce que l'on appelle un **pointeur**.
* Un pointeur est une variable qui va stocker une adresse et indiquer le type associé à cette adresse.
** - Le type d'un pointeur s'écrit "typePointé* nomVariable".
* Le contenu de la mémoire désigné par l'adresse peut être accédé/modifié en "déréférençant" le pointeur.
** - Le "déréférencement" s'écrit "*nomVariable"

::[height:2em;]::

link::../cpp_technical_adresse_pointeurs/index.html[**\(\Rightarrow\) Plus de détails sur les pointeurs**]


=== Références

==== Principe

Comme vu précédemment les pointeurs (qui existent en C) permettent de manipuler des variables par l'indirection de leur adresse. L'utilisation des pointeurs peut cependant devenir rapidement complexe: il faut les initialiser correctement à une adresse valide, et il faut les utiliser par déréférencement avec la syntaxe *nomPointeur.

::[height:2em;]::

Pour simplifier le cas d'utilisation classique des pointeurs pour le passage d'argument, sans la surcharge syntaxique des adresses/déréférencement, le langage C++ introduit la notion de **référence**.

::[height:2em;]::

Une référence est une variable qui, lors de sa déclaration, est un "alias" vers une autre variable. <br>
Une référence s'initialise avec la syntaxe

code::[c++]
type& nomReference = variableExistante;
code::[-]

Exemple:
code::[c++]
int a = 5;
int& ref_a = a;
// désormais ref_a et a désignent strictement la même zone mémoire

ref_a = 8; // a et ref_a valent désormais 8
a = 12;    // a et ref_a valent désormais 12
code::[-]

Les références permettent de modifier les variables d'origine dans une fonction (arguments in/out) tout comme avec le passage par adresse. Par contre, elles sont syntaxiquement plus simples

code::[c++]
void addOne(int& x){
    // x est une référence/un alias vers la variable passée en paramètre
    x = x + 1; // syntaxe légère, il n'y a pas besoin de la syntaxe *x du pointeur
}
int main()
{
    int a = 5;

    // on passe l'argument sans syntaxe particulière
    addOne(a);

    // le contenu de la variable a est modifié
    //  a vaut désormais 6
    std::cout<< a <<std::endl;
}
code::[-]

::[height:2em;]::

__Remarques__:
* - Ne pas confondre la syntaxe d'une référence et d'une adresse - les deux utilisent le symbole &, mais dans des contextes différents.

::[margin-left:2em;]
code::[c++]
// Lors d'une déclaration "type& nomVariable" - il s'agit d'une référence
int& a = b; // a est une référence sur b

// Lors d'une affectation "nomPointeur = &nomVariable" - il s'agit d'une adresse
p = &b; // p est un pointeur qui recoit l'adresse de la zone mémoire associé à b
code::[-]
::

::[height:1em;]::

* - Une référence doit forcément être initialisée sur une variable lors de sa déclaration. 

::[margin-left:2em;]
code::[c++]
int& a; // ce code ne compile pas, il faut initialiser la référence a
code::[-]
::

::[height:1em;]::

* - Il n'est pas possible de changer la référence sur une autre variable après la déclaration.

::[margin-left:2em;]
code::[c++]
int a = 5;
int b = 6;
int& c = a; //c est une référence sur a (déclaration)

c = -1; // désormais a et c valent -1

c = b; // désormais a et c valent 6
       //  mais attention: c reste une référence sur a (défini à la déclaration)
       //  ici c (et donc a) recoivent la copie du contenu de b

c = -1; // a et c valent -1, et b vaut toujours 6
code::[-]
::

::[height:1em;]::

::(.technique)
* En interne, le compilateur implémente la notion de référence (très généralement)  par l'utilisation d'un pointeur. La référence permet surtout de simplifier l'écriture et la lecture du code pour le programmeur (syntactic sugar) et ajoute des contraintes qui évitent certains bugs.
::


==== Passage d'arguments de grande taille

Nous avons vu l'utilisation des références lors de la modification d'une variable dans une fonction. Une autre utilisation classique des références concerne le passage d'argument de grande taille à une fonction, sans nécessairement nécessiter sa modification.

::[height:1em;]::

Considérons un type fictif "vec1000" qui est un vecteur contenant 1000 valeurs flottantes. Et une fonction "norm" prenant en paramètre un vec1000 pour calculer sa norme.

Il est possible de définir cette fonction par le code suivant.
code::[c++]
float norm(vec1000 v)
{
    for(int k=0; k<1000; ++k)
        n += v[k]*v[k];

    return sqrt(n);
}
code::[-]


Ce code est fonctionnel, mais v est un argument passé "par copie". Ce qui signifie qu'à chaque appel à la fonction norm, 1000 valeurs sont copiées (soit 4000 octets), ce qui peut être couteux si cet appel est réalisé dans une boucle d'animation par exemple.

::[height:1em;]::

Si v est passé par adresse, ou par référence, alors il n'y a plus de copie. Le passage d'argument est beaucoup plus léger puisque seule l'adresse est copiée (une adresse ne prenant que 8 octets).

::[height:1em;]::

Le passage par référence n'est cependant pas exempt de défaut, car une fonction norm mal codée pourrait modifier la valeur de v par inadvertance. Ce type d'erreur serait alors difficile à détecter. 

::[height:1em;]::

Une solution à ce problème est de passer v en référence constante (vec1000 const&). 
* - Le passage d'argument est alors rapide
* - Le compilateur vérifie automatiquement que le vecteur de 1000 valeurs n'est pas modifié dans la fonction.

code::[c++]
float norm(vec1000 const& v) // référence constante: rapide et sécurisé
{
    // le corps de la fonction est strictement identique
    for(int k=0; k<1000; ++k)
        n += v[k]*v[k];

    return sqrt(n);
}
code::[-]


==== Bonnes pratiques du passage d'argument

D'une manière générale, il est conseillé de suivre la démarche suivante:

::[height:1em;]::

* - Les variables de **faibles tailles non modifiées** dans une fonction sont passées par **copies** 
::[margin-left:2em;]
code::[c++]
type nomVariable
code::[-]
::

::[height:1em;]::

* - Les variables de **grande taille non modifiées** dans une fonction sont passées par **référence constantes**
::[margin-left:2em;]
code::[c++]
type const& nomVariable
code::[-]
::

::[height:1em;]::

* - Les variables **modifiées** dans une fonction sont passées par **références** 
::[margin-left:2em;]
code::[c++]
type& nomVariable
code::[-]
::
** __(ou pointeur si on préfère expliciter le fait que la variable est modifiée.)__


== Premier programme OpenGL

=== Création d'une fenêtre

Le code présent dans le répertoire **scenes/inf443/02_opengl_cpp/02_opengl_init/** présente le cas minimaliste de la création d'une fenêtre et de l'initialisation d'OpenGL. 
* __Une fois compilé et exécuté, le programme doit afficher une fenêtre (vide) de couleur orangée.__

::[height:1em;]::

::[text-align:center;]
img::assets/window.png[width:100%; max-width:400px;]
::


::[height:1em;]::

La création d'une fenêtre et l'initialisation d'OpenGL sont des étapes techniques qui dépendent du système d'exploitation. Pour les réaliser plus simplement, nous utilisons des bibliothèques externes: 
* - link::http://www.glfw.org/[GLFW] - gestion d'une fenêtre (et gestion des évènements clavier/souris).
* - link::https://github.com/Dav1dde/glad[GLAD] - initialisation des fonctions d'OpenGL.

::[height:1em;]::

::(.technique)
<br>
L'étape de création d'une fenêtre est, dans une très large part, indépendante de l'approche mis en place pour réaliser le rendu graphique. Cependant, la fenêtre doit être capable d'interagir et de synchroniser avec l'API graphique utilisé (dans notre cas, il s'agira d'un link::https://www.khronos.org/opengl/wiki/OpenGL_Context[contexte OpenGL]). 

<p>La création d'une fenêtre sans bibliothèque externe est une opération complexe qui est spécifique à chaque système d'exploitation. Dans la plupart des cas, une bibliothèque dédiée à la gestion d'une fenêtre est utilisée pour gérer cette étape.<br>
Dans notre cas, nous utilisons la bibliothèque link::http://www.glfw.org/[GLFW].
GLFW est une bibliothèque C légère capable de créer des fenêtres compatibles avec un contexte OpenGL. GLFW permet également de gérer des évènements utilisateur tels que les clics/déplacement souris, ou l'appui sur les touches du clavier.</p>

__Remarque: L'installation de GLFW dépend de votre système et a du être réalisé lors de la mise en place du tutoriel d'installation pour votre système__
* - Sous Linux/MacOS, GLFW est installé de manière globale à partir d'un gestionnaire de packages.
* - Sous Windows, les fichiers de la bibliothèque sont fournis localement avec les codes. Il sont compatibles avec la dernière version de visual studio.
::

::[height:1em;]::

Les différentes étapes de l'initialisation de la fenêtre sont réalisées dans la fonction __create_window_using_glfw__. On pourra y noter les fonctions principales et types suivants:

code::[c++]
GLFWwindow* create_window_using_glfw()
{
    ...
    glfwInit();
    GLFWwindow* window = glfwCreateWindow(width, height, "GLFW Window", nullptr, nullptr);
    glfwMakeContextCurrent(window);
    ...
}
code::[-]


* **glfwInit();** est l'appel à une fonction de la bibliothèque GLFW permettant d'initialiser celle-ci. <br> 
* **glfwCreateWindow(...)** est une fonction qui permet d'initialiser une fenêtre graphique. Cette fonction renvoie une variable de type __GLFWwindow*__
* **GLFWwindow* ** est un pointeur sur une classe définie dans la bibliothèque GLFW. Son contenu peut être complexe, mais il n'y a pas besoin d'en avoir connaissance pour utiliser la fenêtre graphique. Il s'agit d'une variable qui est passée aux fonctions de GLFW.


::[height:2em;]::

Le reste de la fonction __main()__ consiste en une boucle qui fait appel aux fonctions suivantes:

code::[c++]
while (!glfwWindowShouldClose(window)) // loop as long as the window is not closed
{
    // Set here the color used to clear the window at each frame
    glClearColor(0.8f, 0.6f, 0.5f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    glfwSwapBuffers(window);
    glfwPollEvents();
}
code::[-]

* **link::https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearColor.xhtml[glClearColor]**(R, G, B, A);
** Il s'agit d'une fonction OpenGL qui indique la couleur à utiliser lors des futurs appels à un "Clear"
* **link::https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClear.xhtml[glClear]**(GL_COLOR_BUFFER_BIT);
** Fonction OpenGL qui réécrit sur le buffer de couleur (l'image à l'écran) avec la couleur paramétrée dans __glClearColor__.
** __rem.__ glClearColor ne fait que paramétrer une couleur, c'est glClear qui "réécrit" une couleur sur la fenêtre.

* **link::https://www.glfw.org/docs/3.3/group__window.html#ga15a5a1ee5b3c2ca6b15ca209a12efd14[glfwSwapBuffers]**(window);
** Fonction de GLFW qui réalise l'échange de buffer pour permettre un __double buffering__
*** Le __double buffering__ consiste à stocker 2 buffers (/images de la scène). Pendant que l'une est modifiée, l'autre est affichée à l'écran. Cela permet d'éviter des clignotements de l'image lors des affichages.
* link::https://www.glfw.org/docs/3.3/group__window.html#ga37bd57223967b4211d60ca1a0bf3c832[**glfwPollEvents**]();
** Fonction de GLFW qui traite la pile d'évènements qui ont pu être reçus (touche clavier, clic/déplacement souris). (pour l'instant ce code n'utilise pas les évènements).

::[height:2em;]::

Considérez désormais le code suivant pour la boucle d'affichage:


code::[c++]
int counter = 0;
while( !glfwWindowShouldClose(window) ) {

    counter = (counter+1)%100;
    float u = counter/99.0f;

    // Set the (R,G,B,A) color to clear the screen
    glClearColor(0.5+std::cos(2*3.14f*u)/2.0f, 1.0f, 0.5f, 1.0f);

    // Clear the screen (designated by the color buffer)
    glClear(GL_COLOR_BUFFER_BIT);

    glfwSwapBuffers(window);
    glfwPollEvents();
}
code::[-]

* &gt; Essayez de comprendre le code
** - Quelles valeurs prend la variable __counter__ ?
** - Quelles valeurs prend la variable __u__ ?
** - Quelles valeurs prend le premier paramètre (Red) de la fonction __glClearColor__ ?


<p>Notez que vous pouvez tester avec d'autres fonctions pour obtenir d'autres effets de changement de couleur.</p>

::(.cpp)
<br>
Notez la syntaxe explicite __counter/99.0f__ et non pas __counter/99__
* - Cette syntaxe permet d'expliciter le fait que le calcul doit être réalisé sur des nombres flottants (l'un des paramètres est un nombre flottant)
* - Dans le cas contraire: __counter/99__ réaliserait un calcul sur des nombres entiers. Le résultat correspondant serait donc égal à 0 (la plupart du temps) ou 1.
::

=== OpenGL et conventions

link::https://www.khronos.org/opengl/[**OpenGL**] est un ensemble de fonctions standardisées (appelé une API) qui permet de mettre en oeuvre de manière très efficace et générique le "pipe-line de rendu graphique". Plus précisément, OpenGL consiste en un ensemble de fonctionnalités permettant de communiquer directement avec la carte graphique (GPU - Graphics Processing Unit), offrant ainsi une approche optimale pour afficher des données 3D en temps-réel.

::[height:1em;]::

__Rem.__ OpenGL n'est pas une "bibliothèque de code", il s'agit uniquement d'un standard d'appels de fonctions et de types qui sont décrits à l'aide du langage C. L'implémentation effective de ces fonctions dépend de votre système, de votre carte graphique, et du driver que vous avez installés.
Les appels OpenGL sont dits de "bas niveau": Ils permettent une communication directe avec votre carte graphique très efficace, mais nécessitent un travail conséquent de mise en place.

::[height:2em;]::

__Rem.__ OpenGL utilise les conventions suivantes de nommage:

* - Les fonctions OpenGL sont dénommés **gl**__FunctionName()__
* - Les valeurs constantes prédéfinies par OpenGL sont des mots en majuscules, séparées par underscore (ex. GL_COLOR_BUFFER_BIT). 
** __Ces "constantes" sont stockées en interne par des nombres entiers, et leurs noms sont remplacés au moment de la compilation par leur valeur numérique.__
* - Les types OpenGL **GL**__type__: GLint, GLfloat, GLenum, etc.
** __Ces types sont utilisés pour avoir la garantie d'un nombre d'octets spécifique en mémoire lors de leur utilisation. Techniquement, C++ ne spécifie pas la taille mémoire des types standards int/float/etc. Cependant dans la grande majorité des cas de nos systèmes, GLint/int et GLfloat/float seront identiques.__
* - Certaines fonctions ont un comportement similaire mais prennent différents types d'arguments. Dans ce cas, la fin du nom de la fonction désigne le nombre et/ou type attendu.
** Exemple des arguments attendus dans le cas de la fonction **link::https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml[glUniform]**
::[font-size:80%; line-height:1.3em;]
*** glUniform**1f**: 1 flottant
*** glUniform**2f**: 2 flottants
*** glUniform**2i**: 2 entiers
*** glUniform**1fv**: 1 flottant passé par adresse
*** glUniform**3fv**: 3 flottants passés par adresse
*** glUniform**Matrix3fv**: 9 flottants -représentant une matrice 3x3- passés par adresse
::

::[height:0.5em;]::

::(.technique)
Ce type de nommage d'une fonction dépendant de ces arguments est nécessaire car OpenGL est une spécification décrite en langage C. Au contraire du C++, le C ne permet pas de "surcharger" une fonction prenant différents types d'arguments - ce qui oblige à avoir un nom de fonction unique pour un type donné d'argument.
::

== Affichage d'un triangle

<p>La seule forme 3D qu'une carte graphique est en mesure d'afficher par le "pipe-line graphique natif" est le triangle. Toutes les formes 3D visibles dans les scènes affichées par les cartes graphiques sont donc généralement formées d'assemblages de triangles.</p>

<p>__Nous allons voir dans cette partie comment afficher un premier triangle à l'aide d'OpenGL. Les parties suivantes consisterons à en afficher plusieurs, et associer ceux-ci à différentes propriétés (couleurs, textures, transformation, etc.) pour visualiser des objets d'apparence plus complexe.__</p>


<p>Le code correspondant à l'affichage d'objets en OpenGL peut généralement être catégorisé en trois étapes</p>

* Étape d'initialisation, formée par
** Mise en place des shaders (1)
** Envoie des données sur la carte graphique (2)
* Demande d'affichage des données (3) 

<p>Les deux premières étapes d'initialisations ne sont exécutées qu'une seule fois. (1) et (2) peuvent être réalisés dans un ordre arbitraire. L'étape (3) quant à elle correspond à la mise en oeuvre du pipe-line graphique (voir cours) et nécessite que les deux étapes précédentes aient été traitées préalablement.</p>

::[height:1em;]::

On considère désormais le code **scenes/inf443/02_opengl_cpp/03_triangle/**
* &gt; Un triangle rouge sur fond noir devrait apparaitre une fois exécuté.

::[height:1em;]::

::[text-align:center]
img::assets/triangle.png[width:100%; max-width:300px;]
::

::[height:2em;]::

Les différentes parties du code permettant d'obtenir ce résultat sont décrites ci-après.


=== (1) Mise en place des shaders

link::../details_shader/index.html[**\(\Rightarrow\) Détails sur ce qu'est un shader**]


::[height:2em;]::

L'exemple du triangle utilise les vertex et fragment shaders suivants (fichiers __shaders/triangle.vert.glsl__ et __shaders/triangle.frag.glsl__)

::[height:1em;]::

Vertex Shader:
code::[glsl]
#version 330 core  // OpenGL 3.3

// Only one argument here: the vertex position
layout (location = 0) in vec3 position; 

void main()
{
    // Output position (in normalized device coordinates) is directly the position
    gl_Position = vec4(position, 1.0);
}
code::[-]

* - **#version 330 core** indique l'utilisation de GLSL 3.30 (en accord avec la version d'OpenGL) <br><br>
* - **layout (location = 0) in vec4 position** indique que le premier paramètre associé à un vertex (position indicée par 0) est reçu dans une variable nommée __position__. Cette variable est un vecteur \((x,y,z)\). Dans ce cas, il n'y a qu'un seul paramètre par sommet. <br><br>
* - Une fois que les variables globales ont été déclarées (ici __position__) le code GLSL définit une fonction __main__ avec le code à exécuter. <br><br>
* - L'un des objectifs du __vertex shader__ est de compléter la variable globale de sortie link::https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/gl_Position.xhtml[gl_Position]. Cette variable contient les coordonnées dans l'espace des __clip coordinates__ utilisés par OpenGL pour afficher la primitive dans la fenêtre. Le type attendu est un vecteur à 4 composantes \((x,y,z,w)\) de l'espace homogène.

::[height:2em;]::

Fragment Shader:
code::[glsl]
#version 330 core  // OpenGL 3.3

// The output variable of the fragment is the color (R,G,B,A)
out vec4 FragColor;

void main()
{
    FragColor = vec4(1.0, 0.0, 0.0, 1.0);
}
code::[-]


* Dans ce cas, la variable globale de sortie est __FragColor__ (vecteur 4D) correspond à la couleur (r,g,b,a) du fragment courant. Ici, le vecteur (1,0,0,0) indique une couleur rouge uniforme.
** __La dernière composante a n'ayant pas d'influence dans cet exemple.__

::[height:1em;]::

::(.technique)
<br>
La fonction __opengl_load_shader__ dont le code est décrit dans le fichier __helper_opengl.cpp__ vous pré-code la lecture des fichiers et la compilation de leur contenu en tant que __shader program__.

::[height:0.5em;]::

Cette étape est une suite d'appels de fonctions OpenGL, et de vérifications d'erreurs. Sauf cas particuliers, vous n'aurez pas à modifier/coder vous même ces étapes.

Les fonctions associées (et leurs documentations) sont disponibles ici:
* - link::https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateShader.xhtml[glCreateShader]
* - link::https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderSource.xhtml[glShaderSource]
* - link::https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompileShader.xhtml[glCompileShader]
* - link::https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glAttachShader.xhtml[glAttachShader]
* - link::https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glLinkProgram.xhtml[glLinkProgram]

::



=== (2) Envoie de données sur la carte graphique

==== Notion de VBO et VAO

<p>Les données d'entrées des shaders, typiquement liées à la définition des maillages tels que les coordonnées des sommets et leurs attributs, doivent être envoyées sur la mémoire de la carte graphique afin de pouvoir être utilisées par les shaders lors de leur exécution pendant l'étape d'affichage.</p>


<p>Ce transfert, de la mémoire RAM vers la mémoire du GPU, est une opération pouvant se révéler couteuse. Ce transfert est donc réalisé, dans la mesure du possible, une unique fois lors de l'étape d'initialisation (et non pas à chaque appel d'affichage dans la boucle d'animation).</p>


<p>Les données sur la carte graphique sont gérées en tant que __buffers__, c'est à dire des blocs de données contigus (similaire à des tableaux). Ces buffers sont appelés **VBO** - **V**ertex **B**uffer **O**bject. Les VBO sont similaires à des pointeurs C: la valeur du VBO est un identifiant d'un buffer sur le GPU. Les données désignées par un VBO peuvent contenir les coordonnées des sommets, mais aussi leurs attributs tels que les couleurs, coordonnées de textures, etc. Plus généralement, les buffers contiennent des données interprétées comme étant __par sommets__, et peuvent être reçus comme variable d'entrée dans le vertex shader.</p>


<p>Les fonctions OpenGL permettent d'initialiser ces buffers à partir des pointeurs (compatible C) depuis le code.</p>


<p>GLSL réalise ces calculs en flottants simples précisions. Pour éviter des conversions supplémentaires, il convient de manipuler les données du code C++ également en simple précision (corresponds aux float et non pas double). OpenGL définit le type link::https://www.khronos.org/opengl/wiki/OpenGL_Type[GLfloat] pour assurer la cohérence d'encodage pour toutes les architectures. 
Au final, manipuler des buffers compatibles OpenGL en C++ reviendra à stocker des données en tant que link::https://en.cppreference.com/w/cpp/container/vector[std::vector]&lt;float&gt; . 
</p>


<p>Les données stockées dans un VBO sont des valeurs génériques, elles peuvent donc désigner différents types d'attributs. Il est donc nécessaire de définir explicitement quelles données du buffer correspondent à quelles variables des shaders. Cette relation est réalisée par un **VAO** - **V**ertex **A**rray **O**bject. Le VAO stocke les relations entre l'organisation mémoire dans le buffer et les variables utilisés dans le shader (dont l'index est indiqué par le __layout__).</p>

::[border:2px solid black; border-radius:10px; padding-top:0.5em; padding-bottom:0.5em; padding-right:0.5em; display:inline-block;]
__En synthèse:__

* **VBO** = Le buffer de données brutes
* **VAO** = L'organisation de ces données
::

::[height:2em;]::

Trois étapes peuvent être identifiées lors de l'envoi de données sur le GPU

* 1. Mise en place des données dans le code C++ en tant que tableau contigu de valeurs.
* 2. Envoie des données sur le GPU et enregistrement de l'identifiant associé: **VBO**.
* 3. Paramétrage de la relation entre l'organisation mémoire des données dans le VBO et les variables d'entrées du vertex shader en utilisant un **VAO**.

==== Code


<p>Ces trois étapes sont illustrées dans le cas du triangle simple par le code ci-après</p>


===== Création de données contigues en mémoire RAM

code::[c++]
// 2.1 Setup contiguous array of floating point value
// ******************************************* //
//     Here the coordinates of the vertices position
const std::vector<GLfloat> position = {
    -0.5f, -0.5f, 0.0f,
     0.5f, -0.5f, 0.0f,
     0.0f,  0.5f, 0.0f
};
code::[-]

::(.cpp)
<br>
**std::vector** est un conteneur de la bibliothèque standard C++.
* Il s'agit d'un buffer/tableau de données dont le stockage est contigue en mémoire.
* Les données du std::vector sont allouées sur le tas. Ce nombre de données contenu peut être grand (uniquement limité par la RAM). 
* Le paramètre entre chevrons &lt; &gt; décrit le paramètre contenu dans le vector (ici des flottants).
* La capacité du std::vector peut être redimensionnée dynamiquement (.resize(), et .push_back()), mais cela doit être réalisé explicitement par le programmeur.
::


===== Envoie des données sur le GPU

code::[c++]
// 2.2 Create VBO - Send data to GPU
// ******************************************* //

GLuint vbo = 0;
// Create an empty VBO identifiant
glGenBuffers(1, &vbo);
// Activate the VBO designated by the variable "vbo"
glBindBuffer(GL_ARRAY_BUFFER, vbo);
// Send data to GPU: Fill the currently designated VBO with the buffer of data passed as parameter
glBufferData(GL_ARRAY_BUFFER, position.size() * sizeof(GLfloat), &position[0], GL_STATIC_DRAW);
// Good practice to set the current VBO to 0 (=disable VBO) after its use
glBindBuffer(GL_ARRAY_BUFFER, 0);
code::[-]

::[height:2em;]::

La copie effective des données entre la RAM et le GPU est réalisée par la fonction 

code::[c++]
glBufferData(GL_ARRAY_BUFFER, position.size()*sizeof(GLfloat), &position[0], GL_STATIC_DRAW );
code::[-]

* link::https://www.khronos.org/registry/OpenGL-Refpages/es1.1/xhtml/glBufferData.xml[glBufferData(GLenum target, GLsizeiptr size, const GLvoid* data, GLenum usage)] est la fonction réalisant le transfert de données
** - __target__: Placé à la constante __GL_ARRAY_BUFFER__ pour envoyer des attributs de sommets 
** - __size__: Taille en octets du buffer. Dans ce cas, il est calculé comme étant le nombre d'éléments de position multipliée part la taille d'un élément (ici GLfloat) 
** - __data__: Adresse du premier élément du buffer. La syntaxe `&amp;vector[0]` permets d'accéder à l'adresse du premier élément du std::vector.
** - __usage__: Parametre permettant d'optimiser l'organisation mémoire sur le GPU en fonction de la modification ultérieure ou non des données. _GL_STATIC_DRAW_ indique que les données ne seront pas modifiées par la suite.

::[height:1em;]::

* __Cette opération est potentiellement couteuse pour un grand nombre de sommets. On préfèrera l'utiliser lors de l'initialisation des données, et éviter de l'utiliser dans la boucle d'affichage.__

::[height:2em;]::

Les autres fonctions sont des opérations plus simple:
* - __glGenBuffers__: Indique à la carte graphique/driver la demande de création d'un buffer. L'appel à cette fonction complète la variable (ici vbo passé en adresse) par un indice entier différent de 0.
* - __glBindBuffer__: Indique à la carte graphique/driver l'indice du buffer à prendre en compte lors des prochaines instructions (ici vbo).


===== Paramétrage du VAO

Dans le cas présent, l'organisation mémoire des données sur le VBO en mémoire du GPU est simple, il n'y a qu'un seul paramètre (positions \((x,y,z)\)) donné de manière contigue.

::[text-align:center; margin-top:1em;]
img::assets/vbo.svg[width:100%; max-width:400px]
::

::[height:1em;]::

Le code associé à cette paramétrisation est le suivant:

code::[c++]
// 2.3 Create VAO - Relation between VBO organization and input variables of shaders
// ******************************************* //
// In this case, we have only one VBO containing triplets of floats, and used as the "layout 0" in the shader
GLuint vao = 0;
// Create an empty VAO identifiant
glGenVertexArrays(1, &vao);
// Activate the VAO designated by the variable "vao"
glBindVertexArray(vao);
// Indicate the VBO to parameterize
glBindBuffer(GL_ARRAY_BUFFER, vbo);
// Activate the use of the variable at index layout=0 in the shader
glEnableVertexAttribArray(0);
// Define the memory model of the current VBO: here contiguous triplet of floating values (x y z) at index layout=0 in the shader
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, nullptr);
// As a good practice, disable VBO and VAO after their use
glBindBuffer(GL_ARRAY_BUFFER, 0);
glBindVertexArray(0);
code::[-]

* - Comme précédemment, les fonctions __glGenVertexArrays__, __glBindVertexArray__, et __glBindBuffer__ permettent de respectivement définir un nouvel indice (glGen...), et d'indiquer les indices à utiliser lors des prochains appels (glBind...).

::[height:2em;]::

La fonction indiquant le paramétrage du 1er (et unique) paramètre pour le VAO est

code::[c++]
glVertexAttribPointer( 0, 3, GL_FLOAT, GL_FALSE, 0, nullptr );
code::[-]



* link::https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml[glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* pointer)]
** - __index__: Indique l'indice de la variable correspondance dans le shader. Ici il s'agit de la variable position au layout=0.
** - __size__: Nombre de composantes à lire depuis le buffer pour chaque sommet. Ici 3 composantes (x, y, z).
** - __type__: Enum indiquant le type de variable du buffer, ici le type GLfloat est indiqué par la constante __GL_FLOAT__ (voir link::https://www.khronos.org/opengl/wiki/OpenGL_Type[OpenGL types conventions]).
** - __normalized__: Indique si la valeur vectorielle doit être normalisée à une norme unitaire avant d'être utilisée dans le shader.
** - __stride__: Indique l'espace entre deux valeurs consécutives dans le buffer. Stride est utilisé lorsque des valeurs sont intercalées entre plusieurs attributs (attributs entrelacés). Dans le cas où les valeurs sont consécutives dans le buffer, stride peut-être conventionnellement placé à 0.
** - __pointer__: Offset indiquant l'indice du premier élément à lire dans le buffer. Dans notre cas, l'offset est de 0. Par compatibilité avec les anciennes versions d'OpenGL, cet offset est indiqué sous forme d'une adresse, la valeur 0 correspond donc à nullptr.








==== Remarques générales sur l'utilisation des fonctions OpenGL


<p>On peut noter la démarche générale d'OpenGL travaillant à l'aide d'identifiants (/handler) que l'on rencontrera dans l'ensemble des programmes. </p>


* Premièrement, un identifiant est créé à l'aide d'une fonction nommée **glGen**__XXX__. Cette fonction ne fait que générer un identifiant (pas de transfert de données, etc). <br><br>
* Avant de réaliser des opérations associées à cet identifiant, celui-ci doit être activé (/"bindé") - c'est-à-dire que l'on indique que les appels suivants feront référence à cet identifiant par la suite. Pour cela, on retrouve l'appel à des fonctions nommées **glBind**__XXX__. Les fonctions glBind ne font que placer l'identifiant à un __état actif__, encore une fois il n'y a pas d'opérations spécifiques. Un identifiant reste actif tant qu'un autre n'est pas activé à sa place. <br><br>
* Une fois activées, les opérations peuvent être réalisées par rapport à ce buffer. <br><br>
* Une fois réalisées, on considère comme bonne pratique de désactiver les identifiants en réalisant un __bind__ sur l'identifiant 0 (**glBind**__XXX__**(0)**). Cela permet de détecter plus facilement certains bugs (oubli d'activation d'identifiant qui aurait alors utilisé l'ancien).


::[height:2em;]::

**Documentation des fonctions au besoin**



* - link::https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenBuffers.xhtml[glGenBuffers]
* - link::https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffer.xhtml[glBindBuffer]
* - link::https://www.khronos.org/registry/OpenGL-Refpages/es1.1/xhtml/glBufferData.xml[glBufferData]

<br>

* - link::https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenVertexArrays.xhtml[glGenVertexArrays]
* - link::https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexArray.xhtml[glBindVertexArray]
* - link::https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml[glEnableVertexAttribArray]
* - link::https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glVertexAttribPointer.xml[glVertexAttribPointer]


=== (3) Affichage des données

<p>Dans la boucle d'animation, afficher des données revient principalement à indiquer le shader à utiliser, activer le VAO, et demander l'affichage. Il n'y a alors plus d'opérations complexes à réaliser sur le CPU, l'ensemble des traitements étant portés par le GPU.</p>


<p>Le code correspondant à l'affichage du triangle est le suivant</p>


code::[c++]
// ************************************************* //
//           3 - Displaying Data                     //
// ************************************************* //

glUseProgram(shader);             // Activate shader program
glBindVertexArray(vao);           // Activate attributes for the drawing
glDrawArrays(GL_TRIANGLES, 0, 3); // Draw 3 vertices
glBindVertexArray(0);
glUseProgram(0);
code::[-]



La demande effective d'affichage est réalisée par la fonction link::https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArrays.xhtml[**glDrawArrays**(GLenum mode, GLint first, GLsizei count)]
* - __mode__: Indique le type de primitive à afficher: ici des triangles par __GL_TRIANGLES__.
* - __first__: Le premier indice de sommet devant être affiché (ici l'indice 0).
* - __count__: Nombre de sommets devant être affichés (ici 3).

<p>__Notez que la demande d'affichage est très courte et simple. Le paramétrage du contenu et de la méthode d'affichage ayant été fait au préalable, et stocké respectivement dans le VBO, VAO et shaders.__</p>



=== Exercices

* &gt; Modifiez dans le code les valeurs des composantes \((x,y)\) du triangle. Essayez de retrouver le système de coordonnées utilisé par OpenGL. Plus précisément, où les points suivants sont-ils placés sur l'écran (gardez une fenêtre carrée) ?
** \((-1,-1)\)
** \((-1,1)\)
** \((1,1)\)
** \((1,-1)\)
** \((0,0)\)



<p>__Note__: Aucune projection n'est appliquée dans le vertex shader, ainsi les coordonnées 3D du triangle correspondent directement aux __Normalized Device Coordinates/Clip Coordinates__ utilisées par OpenGL, et dont les coordonnées \((x,y)\) (une fois normalisées) correspondent aux coordonnées de l'espace image. </p>


* &gt; Modifiez la composante \(z\) des coordonnées du triangle. Différenciez deux cas
** \(z\in[-1,1]\)
** \(|z|>1\)

::[height:2em;]::

* Vous retrouvez la notion de __clip coordinates__: seules les coordonnées (en sortie de vertex shader) situées dans le cube normalisé \([-1,1]\) sont affichées, celles situées en dehors ne sont pas traitées.


==== Modification du shader

<p>&gt; Modifiez le fragment shader pour afficher un triangle uniformément jaune. </p>

<p>&gt; Modifiez le vertex shader pour appliquer une translation et un homothétie ("scaling") sur le triangle.</p>



<p>&gt; En notant que les coordonnées des sommets sont des coordonnées homogènes à 4 dimensions, expliquez la différence visuelle obtenue entre les deux codes suivants dans le vertex shaders</p>


code::[c++]
gl_Position = vec4(position, 1.0);
gl_Position = gl_Position * 2.0;
code::[-]



et 


code::[c++]
gl_Position = vec4(position, 1.0);
gl_Position.xyz = gl_Position.xyz * 2.0;
code::[-]




==== Second triangle


Considérez que la variable __position__ dans le code C++ est désormais initialisée de la manière suivante. (On considèrera que les 3 premières coordonnées correspondent à un triangle, et les 3 suivantes, à un autre triangle.)


code::[c++]
const std::vector<GLfloat> position = {
    -0.5f, -0.5f, 0.0f,
     0.5f, -0.5f, 0.0f,
     0.0f,  0.5f, 0.0f,


     0.9f,  0.9f, 0.0f,
     0.6f,  0.9f, 0.0f,
     0.6f,  0.6f, 0.0f
};
code::[-]


::[height:2em;]::

&gt; Adaptez le code de manière à pouvoir afficher ces deux triangles.


::[text-align:center;]
img::assets/triangle_exercise.png[width:100%; max-width:350px;] 
::

== Variables Uniforms

Dans cette partie, nous allons voir comment envoyer des paramètres à la carte graphique par le biais de variables appelées **__uniforms__** dans les shaders.

::[height:2em;]::

**Uniform**: Un paramètre "uniform" est une variable d'un shader qui va avoir la même valeur pour l'ensemble des sommets et fragments d'un même appel d'affichage. La valeur du paramètre uniform est passée du programme vers le shader avant l'affichage de l'objet. Cette valeur peut être modifiée d'un affichage à l'autre.

=== Exemple d'utilisation

==== Principe

Considérons le cas d'un objet que l'on souhaite animer au cours du temps.
Pour cela, il est nécessaire d'utiliser des coordonnées différentes à chaque frame de l'animation.

::[height:1em;]::

Considérons une animation simple consistant en un déplacement d'une forme. Une approche naïve pour appliquer cette rotation consisterait à calculer de nouvelles coordonnées dans le programme C++ à chaque boucle d'itération, puis de renvoyer celles-ci sur le GPU.
Cette approche est fonctionnelle, mais peut être couteuse en temps de calcul sur des objets de taille importante dû:
* 1- Au calcul de la transformation réalisée sur le CPU sur chaque sommet de l'objet à chaque frame
* 2- A l'envoie des nouvelles coordonnées de la mémoire RAM vers la mémoire du GPU (utilisation de la bande passante pour du transfert de données).

::[height:1em;]::

Une approche plus efficace consiste à appliquer cette translation directement le shader (le vertex shader dans ce cas). La valeur de la translation pouvant alors être modifiée à chaque nouvelle frame. La valeur de cette translation étant la même pour tous les sommets d'un même objet, il est possible d'utiliser pour cela un paramètre "uniform".

::[height:1em;]::

==== Code

Considérez désormais le code **scenes/inf443/02_opengl_cpp/04_uniform/** <br> <br>


Les étapes à réaliser sont les suivantes:

===== Dans le shader

Le vertex shader contient désormais une variable __uniform vec3 translation__;
Cette variable est utilisée dans le shader pour translater les coordonnées du triangle.

code::[c++]
#version 330 core

layout (location = 0) in vec3 position;

// This variable must be set in the C++ code before the draw call
uniform vec3 translation;

void main()
{
    vec3 p = position + translation;
    gl_Position = vec4(p, 1.0);
}
code::[-]

===== Dans le code C++

Un vecteur contenant les composantes de la translation est créé dans le code C++. Les valeurs de ce vecteur sont modifiées d'une frame à l'autre dans la boucle d'affichage.

code::[c++]
float tr[3] = {0.3f*std::sin(t), 0.3f*std::cos(t), 0.0f};
code::[-]

::[height:1em;]::

::(.cpp)
* - Contrairement au GLSL (dans le shader), le C++ ne définit pas par défaut de structure __vec3__. On utilise dans le cas de ce programme le type "float variable[N]" qui génère un vecteur de N valeurs (souvent appelée "tableau") placées sur la pile. Le nombre N doit être connu au moment de la compilation.
** __Un type vec3 est défini dans la librairie CGP, mais elle n'est pas utilisée dans ce code d'exemple minimaliste.__
* - Le type "float T[N]" est similaire à l'appel "std::array<float,N> T" - à l'exception de la copie (std::array permet de copier les données, alors que float T[N] donne accès au pointeur sur le 1er élément du tableau).
::

::[height:1em;]::


Les valeurs de la translation sont envoyées à la carte graphique en tant qu'__uniform__ -- dans notre cas il s'agit de copier les valeurs de "tr" du code C++ vers la variable "translation" du vertex shader. <br>

Cette opération se réalise en 2 étapes:
* 1- Récupération d'un indice de position de la variable __uniform__ que l'on vise dans le shader (translation dans notre cas) à l'aide de la fonction link::https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformLocation.xhtml[**glGetUniformLocation**]. 
* 2- Envoie de la valeur de tr sur la variable __uniform__ désignée à l'aide de link::https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml[**glUniform**(3f)].

code::[c++]
// Locate the targeted uniform variable in the shader
GLint uniform_translation_location = glGetUniformLocation(shader, "translation");
...

// Send the current value to the uniform
glUniform3f(uniform_translation_location, tr[0], tr[1], tr[2]);
code::[-]

::[height:2em;]::

L'exécution de ce code permet d'afficher un triangle animé d'un mouvement de translation le long d'un cercle.

::[text-align:center;]
videoplay::assets/triangle_animation.mp4[width:100%;max-width:350px;]
::

::[height:2em;]::

**Remarques**

* - La commande __glGetUniformLocation(shaderID, uniformName)__ renvoie un identifiant entier correspondant à la localisation de la variable __uniformName__ dans le shader. 
** - Il est nécessaire de connaitre cette "localisation" avant l'utilisation de __glUniform__. 
** - L'indice dépend du shader, mais reste constant pour un shader donné. Il serait également possible d'appeler cette fonction hors de la boucle d'affichage et de ne stocker que l'indice correspondant par la suite.
* - glUniform est une fonction dont le nom dépend des arguments passés en paramètre. 
** - glUniform**3f** permet l'envoi de 3 valeurs flottantes passées en argument (ici tr[0], tr[1], tr[2]).
** - Il serait également possible de passer les arguments par adresse avec la commande
***  __glUniform**3fv**(uniform_translation_location, tr);__
* - Le nom de la variable utilisé dans le code C++ et sa correspondance en variable __uniform__ dans le shader sont indépendants. Ils peuvent être le même ou différent (nous aurions pu appeler la variable "tr" translation).

::[height:2em;]::

**Ordres des opérations**

* - **glGetUniformLocation** peut être appelé n'importe quand avant l'utilisation de glUniform (potentiellement une unique fois à l'initialisation).
* - **glUniform** doit être appelé:
** - **Après** avoir activé le shader courant: **glUseProgram(...)**
*** __En effet glUniform n'agit que sur le shader qui est activé.__
** - **Avant** l'appel à la fonction de draw (**glDrawArrays(...)**)
*** __Cette valeur sera celle utilisée dans le shader à chaque appel de draw.__
*** __La valeur __uniform__ n'est pas ré-initialisée automatiquement après l'affichage, ni au début d'une nouvelle frame. Elle gardera sa valeur pour les appels d'affichage qui suivent tant qu'elle n'est pas mise à jour.__



=== Exercice


**Remarque préliminaire:** Lors d'une animation il est important d'effacer l'image après chaque frame.

* **&gt** Commentez la ligne __glClear(GL_COLOR_BUFFER_BIT);__ et observez le résultat obtenu.

::[height:2em;]::

**Couleur paramétrée**

* **&gt** Modifiez le shader et introduisez les variables nécessaires afin de pouvoir paramétrer la couleur du triangle depuis la code C++.

::[height:1em;]::

* Aide:
** - Vous pouvez ajouter une variable de type vec3 pour désigner une couleur (r,g,b) dans le fragment shader. 
*** __Les variables uniforms sont accessibles similairement depuis le vertex et fragment shader.__
** - Il faudra rechercher la localisation de votre nouvelle variable __uniform__ de couleur à l'aide de glGetUniformLocation
** - Vous pouvez créer dans votre code C++ une variable stockant 3 flottants décrivant la couleur souhaitée.
** - Puis vous enverrez cette couleur à la carte graphique à l'aide de l'appel glUniform(3f).

::[height:2em;]::

**Rotation**

* **&gt** Modifiez le shader et introduisez les variables nécessaires afin d'appliquer une rotation du triangle depuis la code C++.

::[height:1em;]::

* Aide:
** - Vous pouvez définir dans le code C++ une rotation comme matrice \(3 \times 3\) - se stockant comme un vecteur contigu de 9 composantes.

::[margin-left:4em;]
code::[c++]
float rotation[9] = {
    std::cos(t),-std::sin(t), 0,
    std::sin(t), std::cos(t), 0,
              0,           0, 1,
};
code::[-]
::

** - L'envoi d'une variable __uniform__ de type matrice peut se réaliser avec l'appel

::[margin-left:4em;]
code::[c++]
glUniformMatrix3fv(uniform_rotation_location, 1, GL_TRUE, &rotation[0]);
code::[-]
::

** - Cette variable correspond alors à un type __mat3__ en GLSL.

::(.technique)
* - Le second argument "1" correspond au nombre de matrices envoyées, ici une seule.
* - Le troisième argument "GL_TRUE" indique que la matrice doit être transposée avant d'être utilisée dans le shader.
** GLSL utilise la convention où les matrices sont définies par colonne, alors que celle-ci est définie par ligne.
* - Le dernier argument pourrait être simplement "rotation" à  la place de "&rotation[0]" en utilisant le type float [9]. Cependant, la syntaxe &rotation[0] (adresse du 1er élément) sera plus générique lors de l'utilisation d'autres types.
::


::[height:2em;]::

**Affichage de plusieurs triangles**

::[height:1em;]::

Modifiez l'initialisation de la variable __position__ pour être définie par

code::[c++]
std::vector<GLfloat> const position = {
    -0.5f, -0.5f, 0.0f,
     0.5f, -0.5f, 0.0f,
     0.0f,  0.5f, 0.0f, 

     0.2f,  0.0f, 0.0f,
     0.8f,  0.0f, 0.0f,
     0.8f,  0.6f, 0.0f
};
code::[-]

Ces coordonnées peuvent être utilisées pour afficher deux triangles différents.

::[height:2em;]::

**&gt;** Adaptez votre code C++ pour représenter la scène suivante en utilisant un seul shader:

::[text-align:center;]
videoplay::assets/animation_exercise.mp4[width:100%; max-width:350px;]
::

Aide:
* - Le shader que vous avez réalisé (paramètre d'une translation, rotation, et couleur) n'a pas besoin d'être modifié.
* - Vous pouvez réaliser deux appels d'affichages d'affilés, chacun affichant un triangle.
* - Chaque appel d'affichage doit être précédé de l'envoi des paramètres __uniforms__ appropriés.
** __N'oubliez pas que la valeur d'un paramètre uniform est utilisée dans tous les affichages qui en suivent. Si vous souhaitez le modifier, il est nécessaire de le mettre à jour avant chaque affichage.__

::[height:2em;]::

== Attributs des sommets

Cette partie correspond au code du répertoire: **scenes/inf443/02_opengl_cpp/05_vertex_attributes/** 

::[height:1em;]::

__Rem. Il s'agit principalement d'une description informative optionnelle. Il vous sera possible d'y revenir plus tard si vous souhaitez mieux comprendre le fonctionnement d'openGL.__

::[height:1em;]::

Lors de l'affichage d'un maillage, la seule connaissance des coordonnées des sommets n'est pas suffisante. Il est également nécessaire d'associer à chaque sommet d'autres informations telles que:
* - La normale au sommet pour le calcul d'illumination
* - Des coordonnées paramétriques (u,v) pour l'utilisation d'une texture
* - Une couleur pour permettre d'avoir une couleur définie par sommet
* - __ou toute autre information associée à chaque sommet du maillage utile pour l'affichage__.


::[height:2em;]::

Considérez le cas du code d'exemple présentant un triangle où chacun des trois sommets est associé, respectivement, à la couleur rouge, verte et bleue.


::[text-align:center]
img::assets/colored_triangle.png[width:100%; max-width:300px]
::


<br><br>
**Vertex shader**
<br>

code::[c++]
#version 330 core  // OpenGL 3.3

// 2 per-vertex attributes: 
//  - position at location 0
//  - color at location 1
layout (location = 0) in vec3 position; 
layout (location = 1) in vec3 color;

out vec3 color_fragment;

void main()
{
    color_fragment = color; // this variable will be used in the fragment shader

    // Output position (in normalized device coordinates) is directly the position
    gl_Position = vec4(position, 1.0);
}
code::[-]

Le vertex shader reçoit désormais deux attributs par sommet:
* - Une coordonnée (à l'indice/location 0)
* - Une couleur (à l'indice/location 1)
** __Rem. la "location" est choisie arbitrairement. L'important est d'être cohérent dans les indices entre le shader et le code C++ car elle réalise la correspondance entre les données envoyées et leur utilisation.__

<br>

La donnée de couleur n'est pas utilisée directement dans le vertex shader, mais doit être "passée" au fragment shader. <br>
Le principe est le suivant:
* - Dans le vertex shader, la variable à "passer" au fragment shader est déclarée avec le mot clé __out__
* - Puis il sera "reçu" dans le fragment shader sous le même nom en tant que paramètre __in__.








<br><br>
**Fragment shader**
<br>

Le fragment shader reçoit en tant que __in__ la couleur attribuée au sommet. 

** __Rem. La variable reçue dans le fragment shader par ce biais (in/out) correspond à l'interpolation linéaire des valeurs de ce paramètre issu du vertex shader vis-à-vis des 3 sommets du triangle auquel il appartient.__

code::[c++]
#version 330 core  // OpenGL 3.3

// Input interpolated from the vertex shader
in vec3 color_fragment;

// The output variable of the fragment is the color (R,G,B,A)
out vec4 FragColor;

void main()
{
    FragColor = vec4(color_fragment, 1.0);
}
code::[-]


<br><br>
**Code C++**
<br>


Il est nécessaire de déclarer les données des coordonnées et des couleurs, et d'envoyer ces informations à la carte graphique sous forme de VBO. Dans cet exemple, nous déclarons 2 buffers qui seront associés à 2 VBO distincts: l'un pour les coordonnées et l'autre pour la couleur.

Déclaration des données:
code::[c++]
//     Here the coordinates of the vertices position
std::vector<GLfloat> position = {
    -0.5f, -0.5f, 0.0f,
     0.5f, -0.5f, 0.0f,
     0.0f,  0.5f, 0.0f
};

//     Here the color of the vertices
std::vector<GLfloat> color = {
    1.0f, 0.0f, 0.0, // vertex 0 - red
    0.0f, 1.0f, 0.0, // vertex 1 - green
    0.0f, 0.0f, 1.0  // vertex 2 - blue
};
code::[-]

::[height:1em;]::

Gestion des deux VBO de position et de couleur:
code::[c++]
// Fill VBO for position
GLuint vbo_position = 0;
glGenBuffers(1, &vbo_position);
glBindBuffer(GL_ARRAY_BUFFER, vbo_position);
glBufferData(GL_ARRAY_BUFFER, position.size() * sizeof(GLfloat), &position[0], GL_STATIC_DRAW);
glBindBuffer(GL_ARRAY_BUFFER, 0);

// Fill VBO for color
GLuint vbo_color = 0;
glGenBuffers(1, &vbo_color);
glBindBuffer(GL_ARRAY_BUFFER, vbo_color);
glBufferData(GL_ARRAY_BUFFER, color.size() * sizeof(GLfloat), &color[0], GL_STATIC_DRAW);
glBindBuffer(GL_ARRAY_BUFFER, 0);
code::[-]

::[height:1em;]::

Création du VAO indiquant quel VBO à utiliser pour chaque attribut du shader

code::[c++]
GLuint vao = 0;
	
glGenVertexArrays(1, &vao);
glBindVertexArray(vao);

// position at layout 0
glBindBuffer(GL_ARRAY_BUFFER, vbo_position);
glEnableVertexAttribArray(0);
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, nullptr);

// position at layout 1
glBindBuffer(GL_ARRAY_BUFFER, vbo_color);
glEnableVertexAttribArray(1);
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, nullptr);

// As a good practice, disable VBO and VAO after their use
glBindBuffer(GL_ARRAY_BUFFER, 0);
glBindVertexArray(0);
code::[-]


::[height:1em;]::

**Question:**

<p> **&gt;** Modifiez les couleurs des sommets à partir du code C++ et vérifiez le résultat obtenu.</p>







== Structure indexée

Cette partie correspond au code du répertoire: **scenes/inf443/02_opengl_cpp/06_indexing/**

::[height:2em;]::

Considérons le cas où l'on souhaite afficher un quadrangle composé de 4 sommets aux positions respectives \(p_0=(0,0,0)\), \(p_1=(1,0,0)\), \(p_2=(1,1,0)\), \(p_3=(0,1,0)\). <br>
Ce quadrangle est composé lui-même de deux triangles \((p_0,p_1,p_2)\) et \((p_0,p_2,p_3)\).

::[height:0.5em;]::

::[text-align:center;]
img::assets/quad_index.png[width:100%; max-width:250px;]
::

::[height:1em;]::

Il est possible d'envoyer à la carte graphique l'information de ces deux triangles sous la forme de 6 coordonnées consécutives des sommets. Cependant, cette approche revient à dupliquer l'information des coordonnées de \(p_0\) et \(p_2\) qui sont partagés par deux triangles. Au delà de la redondance de données, cette structure ne tient pas compte du fait que les sommets \(p_0\) et \(p_2\) correspondent, en principe, à un seul et même point de l'espace. Ainsi, si le programmeur/utilisateur souhaite modifier la coordonnée \(p_0\), il est nécessaire de réaliser la modification à deux endroits différents du buffer - ce qui est une source de lenteur et/ou d'erreur.


::[height:1em;]::

Une manière plus efficace d'encoder une structure de maillage est de séparer la notion de coordonnées géométrique de la connectivité. Cet encodage basé sur l'indexation (__indexing__) est géré de manière native par OpenGL. <br>
Un maillage est alors représenté par deux structures


* - La **géométrie**, correspondant à un vecteur de coordonnées contigües en mémoire (std&colon;&colon;vector de float). Chaque coordonnée de sommet n'y est mentionnée qu'une seule fois. Les sommets ne suivent pas d'ordre particulier.
* - La **connectivité**, correspondant à un vecteur d'indices (std&colon;&colon;vector de unsigned int). Chaque triplet consécutif indique les trois sommets d'un triangle. Chaque indice indique la position des coordonnées dans le vecteur de géométrie.



=== Application au quadrangle




**Déclaration de la structure géométrie/connectivité**

code::[c++]
// Geometry (vertex position)
const std::vector<GLfloat> position = {
    -0.5f, -0.5f, 0.0f,
     0.5f, -0.5f, 0.0f,
     0.5f,  0.5f, 0.0f,
    -0.5f,  0.5f, 0.0f
};

// Connectivity (triangle index)
const std::vector<GLuint> index = {
        0, 1, 2,
        0, 2, 3
};
code::[-]

<br>

**Envoie des données au GPU**



<p>Les indices définissant la connectivité doivent être stockés sur la mémoire du GPU en suivant la même procédure que les VBO de valeurs floats. Attention au fait que le type associé au VBO stockant les indices est __GL_ELEMENT_ARRAY_BUFFER__ (et non pas __GL_ARRAY_BUFFER__).</p>



code::[c++]
// Fill VBO for position
GLuint vbo_position = 0;
glGenBuffers(1, &vbo_position);
glBindBuffer(GL_ARRAY_BUFFER, vbo_position);
glBufferData(GL_ARRAY_BUFFER, position.size()*sizeof(GLfloat), &position[0], GL_STATIC_DRAW );
glBindBuffer(GL_ARRAY_BUFFER, 0);

// Fill VBO for index
glGenBuffers(1, &vbo_index);
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo_index);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, index.size()*sizeof(GLuint), &index[0], GL_STATIC_DRAW );
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
code::[-]

<br>

**Demande d'affichage réalisée à l'aide de la fonction link::https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElements.xhtml[glDrawElements] **



code::[c++]
// Draw call
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo_index);
glDrawElements(GL_TRIANGLES, 3*2, GL_UNSIGNED_INT, nullptr);
code::[-]



* link::https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElements.xhtml[glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid* indices)]
** - __mode__: Indique le type de primitive à afficher. OpenGL est capable d'afficher différents types de link::https://www.khronos.org/opengl/wiki/Primitive[primitives]. Dans notre cas, __GL_TRIANGLES__ interprète chaque triplet d'indice comme un triangle distinct (manière la plus générique de définir un ensemble de triangles). D'autres interprétations sont des triangles sous la forme __STRIP__ ou __FAN__ pouvant être utilisés afin de limiter l'utilisation mémoire et d'accélérer le rendu sur GPU. Finalement, des segments (appelés __line__ en OpenGL) peuvent également être rendus.
** - __count__: Nombre total de sommets à être rendu. Dans le cas présent: 6 sommets (3 sommets par triangles \(\times\) 2 triangles)
** - __type__: Le type de données utilisé pour stocker les indices (unsigned integer ici).
** - __indices__: L'offset (sous forme de pointeur) indiquant le premier élément à être rendu (ici offset à 0).




::[height:2em;]::

**Question**

* **&gt;** Ajoutez un triangle supplémentaire dans le code d'exemple afin d'obtenir la figure suivante


::[text-align:center;]
img::assets/extra_triangle.png[width:100%; max-width:250px;]
::